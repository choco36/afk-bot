import express from 'express'
import http from 'http'
import cors from 'cors'
import { WebSocketServer } from 'ws'
import { v4 as uuidv4 } from 'uuid'
import path from 'path'
import { fileURLToPath } from 'url'
import mineflayer from 'mineflayer'
import url from 'url'
const __filename = fileURLToPath(import.meta.url); const __dirname = path.dirname(__filename)
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || ''
class Manager{constructor(){this.sessions=new Map;this.listeners=new Set}on(fn){this.listeners.add(fn);return()=>this.listeners.delete(fn)}emit(t,p){for(const f of this.listeners)try{f({type:t,payload:p}){}catch{}}list(){return[...this.sessions.values()].map(s=>({id:s.id,status:s.status,host:s.cfg.host,port:s.cfg.port,username:s.bot?.username||s.cfg.username,auth:s.cfg.auth,createdAt:s.createdAt,lastEvent:s.lastEvent,afkMode:s.cfg.afkMode||'jitter'}))}log(id,level,msg){const s=this.sessions.get(id);if(!s)return;const e={ts:Date.now(),level,msg};s.logs.push(e);s.logs.length>800&&s.logs.splice(0,s.logs.length-800);this.emit('log',{id,entry:e})}_anti(s){const b=s.bot,c=s.cfg;if(c.loginOnly)return;const m=c.afkMode||'jitter',i=Math.max(15000,Number(c.afkIntervalMs||60000)),R=(a,b)=>a+Math.random()*(b-a);s.t=setInterval(()=>{try{if(!b?.entity)return;b.look((b.entity.yaw||0)+R(-Math.PI/8,Math.PI/8),R(-.2,.2),true);if(c.keepAliveCmd&&Math.random()<.2)b.chat(c.keepAliveCmd);if(m==='jitter'){b.setControlState('jump',true);setTimeout(()=>b.setControlState('jump',false),250);Math.random()<.5&&b.swingArm('right')}else if(m==='circle'){b.setControlState('forward',true);setTimeout(()=>b.setControlState('forward',false),1200)}else if(m==='strafe'){const side=Math.random()<.5?'left':'right';b.setControlState(side,true);setTimeout(()=>b.setControlState(side,false),700)}else if(m==='walkabout'){const dir=Math.random()<.5?'forward':'back';b.setControlState(dir,true);setTimeout(()=>b.setControlState(dir,false),700)}this.log(s.id,'trace','Anti-AFK '+m)}catch(e){this.log(s.id,'warn','Anti-AFK error: '+(e?.message||e))}},i)}async start(cfg){const id=uuidv4(),s={id,cfg,status:'starting',logs:[],createdAt:Date.now(),lastEvent:'init',bot:null,t:null,r:null};this.sessions.set(id,s);this.emit('sessions',this.list());const go=()=>{this.log(id,'info',`Connecting ${cfg.host}:${cfg.port} (${cfg.auth})`);const b=mineflayer.createBot({host:cfg.host,port:Number(cfg.port||25565),auth:cfg.auth||'microsoft',username:cfg.auth==='offline'?(cfg.username||'Player'):undefined});s.bot=b;const set=x=>{s.status=x;this.emit('sessions',this.list())};b.once('login',()=>{set('online');this.log(id,'ok','Logged in as '+b.username);if(cfg.loginOnly){this.log(id,'info','login-only: quit');setTimeout(()=>{try{b.quit('login-only')}catch{}},500)}});b.once('spawn',()=>{this.log(id,'ok','Spawned');if(cfg.joinCmd){this.log(id,'info','join '+cfg.joinCmd);b.chat(cfg.joinCmd)}this._anti(s)});b.on('messagestr',m=>this.log(id,'chat',m));b.on('message',m=>this.log(id,'chat',m?.toString?m.toString():String(m)));b.on('kicked',r=>{set('kicked');this.log(id,'warn','KICKED: '+r)});b.on('end',()=>{set('ended');this.log(id,'info','Disconnected');if(s.t){clearInterval(s.t);s.t=null}if(cfg.autoReconnect&&!cfg.loginOnly){const d=Number(cfg.reconnectDelayMs||10000);this.log(id,'info','Reconnecting in '+Math.round(d/1000)+'s');s.r=setTimeout(()=>{set('reconnecting');go()},d)}else{this.sessions.delete(id);this.emit('sessions',this.list())}});b.on('error',e=>this.log(id,'error',e?.message||String(e))) }; go(); this.log(id,'hint','If Microsoft auth: see login console for device-code.'); return {id} } stop(id){const s=this.sessions.get(id);if(!s)throw new Error('Session not found');s.r&&clearTimeout(s.r);s.t&&clearInterval(s.t);if(s.bot)try{s.bot.quit('Stopped by user')}catch{};this.sessions.delete(id);this.emit('sessions',this.list())} logs(id){const s=this.sessions.get(id);return s?s.logs:[]}}
const M=new Manager,app=express();app.use(cors());app.use(express.json());app.use(express.static(path.join(__dirname,'public')))
function guard(req,res,next){if(!ADMIN_TOKEN)return next();const a=req.headers.authorization||'';return a===`Bearer ${ADMIN_TOKEN}`?next():res.status(401).json({error:'unauthorized'})}
app.get('/api/me',(req,res)=>res.json({tokenRequired:!!ADMIN_TOKEN}))
app.get('/api/sessions',guard,(req,res)=>res.json(M.list()))
app.post('/api/sessions',guard,async(req,res)=>{const c=req.body||{};if(!c.host)return res.status(400).json({error:'host is required'});if(!c.port)c.port=25565;if(!c.auth)c.auth='microsoft';try{const {id}=await M.start({host:c.host,port:Number(c.port),auth:c.auth,username:c.username||'',joinCmd:c.joinCmd||'',keepAliveCmd:c.keepAliveCmd||'',afkIntervalMs:Number(c.afkIntervalMs||60000),afkMode:c.afkMode||'jitter',autoReconnect:Boolean(c.autoReconnect??true),reconnectDelayMs:Number(c.reconnectDelayMs||10000),loginOnly:Boolean(c.loginOnly??false)});res.json({id})}catch(e){res.status(500).json({error:e?.message||String(e)})}})
app.post('/api/sessions/:id/stop',guard,(req,res)=>{try{M.stop(req.params.id);res.json({ok:true})}catch(e){res.status(404).json({error:e?.message||String(e)})}})
app.post('/api/sessions/:id/chat',guard,(req,res)=>{const {text}=req.body||{};if(!text||!text.trim())return res.status(400).json({error:'text required'});const s=M.sessions.get(req.params.id);if(!s||!s.bot)return res.status(404).json({error:'session/bot not found'});try{s.bot.chat(text.trim());M.log(s.id,'you',text.trim());res.json({ok:true})}catch(e){res.status(500).json({error:e?.message||String(e)})}})
const server=http.createServer(app),wss=new WebSocketServer({server,path:'/ws'});wss.on('connection',(ws,req)=>{if(ADMIN_TOKEN){const q=url.parse(req.url,true).query;if(q.token!==ADMIN_TOKEN){ws.close();return}}const send=m=>{try{ws.send(JSON.stringify(m))}catch{}};send({type:'sessions',payload:M.list()});const off=M.on(send);ws.on('close',off)})
const PORT=process.env.PORT||3000;server.listen(PORT,()=>{console.log('AFK Console PRO (HE) 1.3 at http://localhost:'+PORT);if(ADMIN_TOKEN)console.log('API protected with ADMIN_TOKEN')})
